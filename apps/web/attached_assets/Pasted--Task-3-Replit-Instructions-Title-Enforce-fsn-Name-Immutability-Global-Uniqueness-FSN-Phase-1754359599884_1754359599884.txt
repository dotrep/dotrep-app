âœ… Task 3 â€“ Replit Instructions

Title: Enforce .fsn Name Immutability & Global Uniqueness (FSN Phase 0 â€“ Task 3)

â¸»

ğŸ§  Context

You are working in a Next.js + React + Firebase project for FreeSpace Network (FSN). Users can claim a unique .fsn name, which is soulbound and cannot be changed or reused. This task ensures that each .fsn name:
	â€¢	Can be claimed only once
	â€¢	Is locked forever once claimed
	â€¢	Cannot be deleted or overwritten
	â€¢	Is always stored in lowercase
	â€¢	Is linked to only one Firebase UID

The name claim logic and Firestore integration is already partially implemented in ClaimName.jsx.

â¸»

âœ… Objectives
	1.	Enforce immutability of .fsn name documents
	2.	Enforce global uniqueness (no two users can claim the same name)
	3.	Prevent any user from claiming more than one .fsn
	4.	Protect Firestore from unauthorized updates or deletions
	5.	Store all .fsn names in lowercase only

â¸»

ğŸ”§ Step-by-Step Instructions

â¸»

ğŸ”’ 1. Firestore Security Rules (firestore.rules)

Replace or update your fsnNames rule block with this:

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    match /fsnNames/{fsnName} {
      allow create: if request.auth != null 
        && !exists(/databases/$(database)/documents/fsnNames/$(fsnName));
        
      allow update: if false;
      allow delete: if false;
    }
    
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
  }
}

âœ… This prevents .fsn name overwrites or deletes
âœ… This also allows users to modify only their own profile

â¸»

ğŸ” 2. Update Claim Logic in ClaimName.jsx

In your handleClaim() function, add the following steps before writing the .fsn name:

A. Always convert input to lowercase

const fsnBase = fsnInput.toLowerCase();
const fullFsnName = `${fsnBase}.fsn`;

B. Block duplicate name

const fsnDoc = await getDoc(doc(db, "fsnNames", fullFsnName));
if (fsnDoc.exists()) {
  setError("That .fsn name is already claimed.");
  return;
}

C. Block users from claiming more than one name

const userDoc = await getDoc(doc(db, "users", auth.currentUser.uid));
if (userDoc.exists() && userDoc.data().fsnName) {
  setError("Youâ€™ve already claimed a .fsn name.");
  return;
}

ğŸ“¥ 3. Create .fsn Name Document in Firestore

Continue your claim logic with:

await setDoc(doc(db, "fsnNames", fullFsnName), {
  ownerUID: user.uid,
  email: user.email || null,
  phone: user.phoneNumber || null,
  fingerprint: await generateDeviceFingerprint(),
  ip: await fetchUserIP(),
  claimedAt: serverTimestamp(),
  xpAtClaim: await fetchUserXP(user.uid)
});

ğŸ” 4. Store the .fsn name in the user profile

await updateDoc(doc(db, "users", user.uid), {
  fsnName: fullFsnName
});

ğŸ§ª 5. QA Checklist (for Replit AI)

Test these scenarios:

Test Case	Expected Result
Try to claim a taken name	âŒ Error shown
Try to claim a second .fsn	âŒ Error shown
Try to change .fsn via profile update	âŒ Blocked by security rules
Delete .fsn name doc via Firebase console	âŒ Blocked
Use uppercase or mixed case input	âœ… Stored as lowercase


ğŸ§¾ 6. Optional Audit Log (Advanced)

Add this if you want to track all name claims:

await setDoc(doc(db, "auditLogs", `claim_${fullFsnName}`), {
  uid: user.uid,
  timestamp: serverTimestamp(),
  ip,
  fingerprint,
  email: user.email || null
});

âœ… Summary

You have now:
	â€¢	Locked all .fsn names as permanent, unique, lowercase entries
	â€¢	Enforced 1:1 mapping between user and .fsn
	â€¢	Prevented future edits or reuse of any claimed name
	â€¢	Hardened Firestore rules to eliminate updates or deletions
	â€¢	Fully aligned the system with FSNâ€™s soulbound identity principles